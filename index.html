<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Red Light Nightmare</title>
    <style>
        body { margin: 0; background-color: #000; color: #fff; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; font-family: 'Courier New', Courier, monospace; cursor: none; }
        canvas { background-color: #000; display: block; box-shadow: 0 0 20px rgba(255, 0, 0, 0.3); border: 2px solid #333; }
        #instructions { position: absolute; top: 20px; left: 20px; color: #777; font-size: 14px; z-index: 10; pointer-events: none; }
    </style>
</head>
<body>
    <div id="instructions">WASD: Move | F: Locator Pulse | SHIFT: Sprint | P: Pause | R: Restart</div>
    <canvas id="gameCanvas"></canvas>

<script>
(function() {
// =================================================================================
// GAME CONSTANTS & CONFIGURATION
// =================================================================================
const TILE_SIZE = 32;
const MAP_WIDTH = 75;
const MAP_HEIGHT = 75;
const GAME_STATE = { TITLE: 'TITLE', PLAYING: 'PLAYING', PAUSED: 'PAUSED', KILL_ANIMATION: 'KILL_ANIMATION', GAME_OVER: 'GAME_OVER', WIN: 'WIN' };

// =================================================================================
// INPUT HANDLERS (KEYBOARD & MOUSE)
// =================================================================================
const Input = {
    keys: new Set(),
    mouse: { x: 0, y: 0 },
    init() {
        window.addEventListener('keydown', e => {
            this.keys.add(e.key.toUpperCase());
            if (['W','A','S','D','P','R','F','ARROWUP','ARROWDOWN','ARROWLEFT','ARROWRIGHT','SHIFT'].includes(e.key.toUpperCase())) e.preventDefault();
        });
        window.addEventListener('keyup', e => this.keys.delete(e.key.toUpperCase()));
        window.addEventListener('mousemove', e => {
            const rect = Game.canvas.getBoundingClientRect();
            const scaleX = Game.canvas.width / rect.width;
            const scaleY = Game.canvas.height / rect.height;
            this.mouse.x = (e.clientX - rect.left) * scaleX;
            this.mouse.y = (e.clientY - rect.top) * scaleY;
        });
    },
    isDown(key) { return this.keys.has(key.toUpperCase()); }
};

// =================================================================================
// AUDIO ENGINE
// =================================================================================
const Sound = {
    audioCtx: null, mainGain: null, distortionFilter: null, isChasingMusicPlaying: false, cricketTimer: null, glitchLoopNode: null, chaseGlitchAudio: null,
    heartbeat: { audio: null, timeout: null, nextBeatTime: 0 },
    init() {
        if (!this.audioCtx) {
            try {
                this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                this.mainGain = this.audioCtx.createGain();
                this.distortionFilter = this.audioCtx.createBiquadFilter();
                this.distortionFilter.type = 'lowpass'; this.distortionFilter.frequency.value = 22050;
                this.mainGain.connect(this.distortionFilter).connect(this.audioCtx.destination);
            } catch(e) { console.error("Web Audio API not supported."); }
        }
    },
    play(soundType) {
        if (!this.audioCtx) return;
        const now = this.audioCtx.currentTime;
        let osc, gain, noise, buffer;
        const createAndConnect = (node) => { node.connect(this.mainGain); return node; };
        switch (soundType) {
            case 'footstep': gain = createAndConnect(this.audioCtx.createGain()); gain.gain.setValueAtTime(0.06, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1); const bandpass = this.audioCtx.createBiquadFilter(); bandpass.type = 'bandpass'; bandpass.frequency.value = 1800; bandpass.Q.value = 0.8; noise = this.audioCtx.createBufferSource(); buffer = this.audioCtx.createBuffer(1, this.audioCtx.sampleRate * 0.1, this.audioCtx.sampleRate); let footstepData = buffer.getChannelData(0); for(let i=0; i<buffer.length; i++) footstepData[i] = Math.random() * 2 - 1; noise.buffer = buffer; noise.connect(bandpass).connect(gain); noise.start(now); noise.stop(now+0.1); break;
            case 'blood_step':
                gain = createAndConnect(this.audioCtx.createGain()); gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                const lpFilter = this.audioCtx.createBiquadFilter(); lpFilter.type = 'lowpass'; lpFilter.frequency.value = 600;
                noise = this.audioCtx.createBufferSource(); buffer = this.audioCtx.createBuffer(1, this.audioCtx.sampleRate * 0.15, this.audioCtx.sampleRate); let bloodData = buffer.getChannelData(0); for(let i=0; i<buffer.length; i++) bloodData[i] = Math.random() * 2 - 1; noise.buffer = buffer; noise.connect(lpFilter).connect(gain); noise.start(now); noise.stop(now+0.15); break;
            case 'clone_footstep': gain = createAndConnect(this.audioCtx.createGain()); gain.gain.setValueAtTime(0.08, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15); const bp2 = this.audioCtx.createBiquadFilter(); bp2.type = 'bandpass'; bp2.frequency.value = 1500; bp2.Q.value = 0.7; noise = this.audioCtx.createBufferSource(); buffer = this.audioCtx.createBuffer(1, this.audioCtx.sampleRate * 0.15, this.audioCtx.sampleRate); let cFootData = buffer.getChannelData(0); for(let i=0; i<buffer.length; i++) cFootData[i] = Math.random() * 2 - 1; noise.buffer = buffer; noise.connect(bp2).connect(gain); noise.start(now); noise.stop(now+0.15); break;
            case 'kill_sequence': 
                this.playFinalThump();
                const roarGain = createAndConnect(this.audioCtx.createGain()); roarGain.gain.setValueAtTime(0.8, now); roarGain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
                const roarOsc = this.audioCtx.createOscillator(); roarOsc.type = 'sawtooth'; roarOsc.frequency.setValueAtTime(60, now); roarOsc.frequency.exponentialRampToValueAtTime(30, now + 0.8);
                const roarDistortion = this.audioCtx.createWaveShaper(); const amount = 600; const n_samples = 44100; const curve = new Float32Array(n_samples); for (let i = 0; i < n_samples; ++i) { const x = i * 2 / n_samples - 1; curve[i] = (3 + amount) * x * 20 * Math.PI / 180 / (Math.PI + amount * Math.abs(x)); } roarDistortion.curve = curve; roarDistortion.oversample = '4x';
                roarOsc.connect(roarDistortion).connect(roarGain); roarOsc.start(now); roarOsc.stop(now+0.8);
                break;
            case 'jumpscare_freeze':
                if (this.glitchLoopNode) this.glitchLoopNode.osc.stop();
                gain = createAndConnect(this.audioCtx.createGain()); gain.gain.setValueAtTime(0.4, now);
                osc = this.audioCtx.createOscillator(); osc.type = 'sawtooth'; osc.frequency.value = 55;
                const lfo = this.audioCtx.createOscillator(); lfo.type = 'square'; lfo.frequency.value = 15;
                const lfoGain = this.audioCtx.createGain(); lfoGain.gain.value = 5;
                const filter = this.audioCtx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 500; filter.Q.value = 5;
                lfo.connect(lfoGain).connect(osc.frequency); osc.connect(filter).connect(gain);
                osc.start(now); lfo.start(now);
                this.glitchLoopNode = { osc, lfo, gain };
                break;
            case 'collectible': osc = this.audioCtx.createOscillator(); gain = createAndConnect(this.audioCtx.createGain()); osc.type = 'sine'; osc.frequency.setValueAtTime(800, now); osc.frequency.exponentialRampToValueAtTime(1600, now + 0.2); gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2); osc.connect(gain); osc.start(now); osc.stop(now + 0.2); break;
            case 'branch_snap': gain = createAndConnect(this.audioCtx.createGain()); gain.gain.setValueAtTime(0.3, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3); noise = this.audioCtx.createBufferSource(); buffer = this.audioCtx.createBuffer(1, this.audioCtx.sampleRate * 0.3, this.audioCtx.sampleRate); let snapData = buffer.getChannelData(0); for (let i = 0; i < buffer.length; i++) snapData[i] = Math.random() * 2 - 1; noise.buffer = buffer; const snapFilter = this.audioCtx.createBiquadFilter(); snapFilter.type = 'highpass'; snapFilter.frequency.setValueAtTime(1000, now); snapFilter.Q.value = 2; noise.connect(snapFilter).connect(gain); noise.start(now); noise.stop(now + 0.3); break;
            case 'static_burst': gain = createAndConnect(this.audioCtx.createGain()); gain.gain.setValueAtTime(0.15, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2); noise = this.audioCtx.createBufferSource(); buffer = this.audioCtx.createBuffer(1, this.audioCtx.sampleRate * 0.2, this.audioCtx.sampleRate); let staticData = buffer.getChannelData(0); for (let i = 0; i < buffer.length; i++) staticData[i] = Math.random() * 2 - 1; noise.buffer = buffer; noise.connect(gain); noise.start(now); noise.stop(now + 0.2); break;
            case 'locator_pulse': gain = createAndConnect(this.audioCtx.createGain()); gain.gain.setValueAtTime(0, now); gain.gain.linearRampToValueAtTime(0.3, now+0.1); gain.gain.linearRampToValueAtTime(0, now+1.0); osc = this.audioCtx.createOscillator(); osc.type = 'sine'; osc.frequency.setValueAtTime(300, now); osc.frequency.exponentialRampToValueAtTime(100, now+1.0); osc.connect(gain); osc.start(now); osc.stop(now+1.0); break;
            case 'figure_vanish':
                gain = createAndConnect(this.audioCtx.createGain()); gain.gain.setValueAtTime(0.25, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                noise = this.audioCtx.createBufferSource(); buffer = this.audioCtx.createBuffer(1, this.audioCtx.sampleRate * 0.5, this.audioCtx.sampleRate);
                let vanishData = buffer.getChannelData(0); for(let i=0; i<buffer.length; i++) vanishData[i] = Math.random() * 2 - 1; noise.buffer = buffer;
                const vanishFilter = this.audioCtx.createBiquadFilter(); vanishFilter.type = 'bandpass'; vanishFilter.frequency.setValueAtTime(3000, now); vanishFilter.Q.value = 5;
                noise.connect(vanishFilter).connect(gain); noise.start(now); noise.stop(now+0.5);
                break;
        }
    },
    stopGlitchLoop() {
        if (this.glitchLoopNode) {
            const now = this.audioCtx.currentTime;
            this.glitchLoopNode.gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
            this.glitchLoopNode.osc.stop(now + 0.1);
            this.glitchLoopNode.lfo.stop(now + 0.1);
            this.glitchLoopNode = null;
        }
    },
    startChaseGlitchAudio() {
        if (!this.audioCtx || this.chaseGlitchAudio) return;
        const now = this.audioCtx.currentTime;
        const noise = this.audioCtx.createBufferSource();
        const bufferSize = this.audioCtx.sampleRate * 2;
        const buffer = this.audioCtx.createBuffer(1, bufferSize, this.audioCtx.sampleRate);
        let data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) { data[i] = Math.random() * 2 - 1; }
        noise.buffer = buffer; noise.loop = true;
        const filter = this.audioCtx.createBiquadFilter(); filter.type = 'bandpass'; filter.frequency.value = 1500; filter.Q.value = 10;
        const lfo = this.audioCtx.createOscillator(); lfo.type = 'square'; lfo.frequency.value = 8;
        const lfoGain = this.audioCtx.createGain(); lfoGain.gain.value = 800;
        const gain = this.audioCtx.createGain(); gain.gain.setValueAtTime(0, now); gain.gain.linearRampToValueAtTime(0.12, now + 0.1);
        lfo.connect(lfoGain).connect(filter.frequency); noise.connect(filter).connect(gain).connect(this.mainGain);
        noise.start(now); lfo.start(now);
        this.chaseGlitchAudio = { noise, lfo, gain };
    },
    stopChaseGlitchAudio() {
        if (!this.audioCtx || !this.chaseGlitchAudio) return;
        const now = this.audioCtx.currentTime;
        this.chaseGlitchAudio.gain.gain.cancelScheduledValues(now);
        this.chaseGlitchAudio.gain.gain.setValueAtTime(this.chaseGlitchAudio.gain.gain.value, now);
        this.chaseGlitchAudio.gain.gain.linearRampToValueAtTime(0, now + 0.05);
        this.chaseGlitchAudio.noise.stop(now + 0.05);
        this.chaseGlitchAudio.lfo.stop(now + 0.05);
        this.chaseGlitchAudio = null;
    },
    startHeartbeat() {
        if (!this.audioCtx || this.heartbeat.audio) return;
        const gain = this.audioCtx.createGain();
        gain.connect(this.mainGain);
        this.heartbeat.audio = { gain };
        this.heartbeat.nextBeatTime = this.audioCtx.currentTime;
        this.scheduleBeat();
    },
    stopHeartbeat() {
        if (this.heartbeat.timeout) clearTimeout(this.heartbeat.timeout);
        this.heartbeat.audio = null;
        this.heartbeat.timeout = null;
    },
    scheduleBeat() {
        if (!this.heartbeat.audio) return;
        const now = this.audioCtx.currentTime;
        const delay = this.heartbeat.nextBeatTime - now;
        this.heartbeat.timeout = setTimeout(() => {
            if (!this.heartbeat.audio) return;
            this.playThump();
            setTimeout(() => { if (this.heartbeat.audio) this.playThump(); }, 120);
            this.scheduleBeat();
        }, delay * 1000);
    },
    playThump() {
        if (!this.audioCtx || !this.heartbeat.audio) return;
        const now = this.audioCtx.currentTime;
        const osc = this.audioCtx.createOscillator();
        const thumpGain = this.audioCtx.createGain();
        osc.connect(thumpGain).connect(this.heartbeat.audio.gain);
        osc.type = 'sine';
        osc.frequency.setValueAtTime(80, now);
        osc.frequency.exponentialRampToValueAtTime(40, now + 0.15);
        thumpGain.gain.setValueAtTime(1, now);
        thumpGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
        osc.start(now);
        osc.stop(now + 0.15);
    },
    updateHeartbeat(distance) {
        if (!this.audioCtx || !this.heartbeat.audio) return;
        const maxDist = 25 * TILE_SIZE;
        const minDist = TILE_SIZE;
        const clampedDist = Math.max(minDist, Math.min(distance, maxDist));
        const proximity = 1 - ((clampedDist - minDist) / (maxDist - minDist));
        const bpm = 55 + (115 * proximity * proximity);
        const delayBetweenPairs = 60 / bpm;
        const volume = 0.08 + (0.32 * proximity);
        this.heartbeat.audio.gain.gain.linearRampToValueAtTime(volume, this.audioCtx.currentTime + 0.1);
        const now = this.audioCtx.currentTime;
        if (this.heartbeat.nextBeatTime < now) {
            this.heartbeat.nextBeatTime = now + delayBetweenPairs;
        }
    },
    playFinalThump() {
        if (!this.audioCtx) return;
        const now = this.audioCtx.currentTime;
        const osc = this.audioCtx.createOscillator();
        const thumpGain = this.audioCtx.createGain();
        thumpGain.connect(this.mainGain);
        osc.connect(thumpGain);
        osc.type = 'sine';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.exponentialRampToValueAtTime(30, now + 0.25);
        thumpGain.gain.setValueAtTime(0.7, now);
        thumpGain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
        osc.start(now);
        osc.stop(now + 0.25);
    },
    ambientSources: {},
    startAmbientSounds() {
        if (!this.audioCtx || this.cricketTimer) return;
        const scheduleChirp = () => {
            this.cricketTimer = setTimeout(() => {
                const panner = this.audioCtx.createStereoPanner();
                panner.pan.value = Math.random() * 1.6 - 0.8;
                panner.connect(this.mainGain);
                const chirpCount = 2 + Math.floor(Math.random() * 4);
                for (let i = 0; i < chirpCount; i++) {
                    const chirpTime = this.audioCtx.currentTime + i * (0.1 + Math.random() * 0.05);
                    const osc = this.audioCtx.createOscillator();
                    const gain = this.audioCtx.createGain();
                    osc.connect(gain).connect(panner);
                    osc.frequency.value = 4000 + (Math.random() - 0.5) * 300;
                    gain.gain.setValueAtTime(0.05, chirpTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, chirpTime + 0.1);
                    osc.start(chirpTime);
                    osc.stop(chirpTime + 0.1);
                }
                scheduleChirp();
            }, 4000 + Math.random() * 4000);
        };
        scheduleChirp();
    },
    stopAmbientSounds() { if (this.cricketTimer) { clearTimeout(this.cricketTimer); this.cricketTimer = null; } },
    startMainAmbient() {
        if (!this.audioCtx || Object.keys(this.ambientSources).length > 0) return;
        const createOscSource = (type, freq, vol, filterFreq) => {
            const osc = this.audioCtx.createOscillator(); osc.type = type; osc.frequency.value = freq; const gain = this.audioCtx.createGain(); gain.gain.value = vol;
            if(filterFreq) { const filter = this.audioCtx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = filterFreq; osc.connect(filter).connect(gain); } else { osc.connect(gain); }
            gain.connect(this.mainGain); osc.start(); return { osc, gain };
        };
        const createPinkNoiseSource = (vol) => {
            const bufferSize = 2 * this.audioCtx.sampleRate; const buffer = this.audioCtx.createBuffer(1, bufferSize, this.audioCtx.sampleRate);
            let output = buffer.getChannelData(0); let b0=0,b1=0,b2=0,b3=0,b4=0,b5=0,b6=0;
            for (let i = 0; i < bufferSize; i++) {
                let white = Math.random() * 2 - 1;
                b0 = 0.99886 * b0 + white * 0.0555179; b1 = 0.99332 * b1 + white * 0.0750759; b2 = 0.96900 * b2 + white * 0.1538520; b3 = 0.86650 * b3 + white * 0.3104856; b4 = 0.55000 * b4 + white * 0.5329522; b5 = -0.7616 * b5 - white * 0.0168980;
                output[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362; output[i] *= 0.11; b6 = white * 0.115926;
            }
            const source = this.audioCtx.createBufferSource(); source.buffer = buffer; source.loop = true;
            const gain = this.audioCtx.createGain(); gain.gain.value = vol;
            source.connect(gain).connect(this.mainGain); source.start();
            return { osc: source, gain: gain };
        };
        this.ambientSources.rumble = createOscSource('sine', 30, 0.04);
        this.ambientSources.wind = createPinkNoiseSource(0.03);
        this.ambientSources.monsterHum = createOscSource('sawtooth', 40, 0, 150);
    },
    startChaseMusic(isFinal) {
        if (!this.audioCtx) return;
        if(this.isChasingMusicPlaying) this.stopChaseMusic();
        this.isChasingMusicPlaying = true;
        const now = this.audioCtx.currentTime;
        const createChaseSource = (freq, detune, vol) => {
            const osc = this.audioCtx.createOscillator(); osc.type = 'sawtooth'; osc.frequency.value = freq; osc.detune.value = detune;
            const gain = this.audioCtx.createGain(); gain.gain.setValueAtTime(0, now); gain.gain.linearRampToValueAtTime(vol, now + 0.5);
            osc.connect(gain).connect(this.mainGain); osc.start(); return { osc, gain };
        };
        this.ambientSources.chaseBass = createChaseSource(isFinal ? 60 : 50, 0, 0.08);
        this.ambientSources.chasePulse = createChaseSource(isFinal ? 66 : 55, 10, isFinal ? 0.09 : 0.08);
    },
    stopChaseMusic() {
        if (!this.isChasingMusicPlaying) return; this.isChasingMusicPlaying = false;
        const now = this.audioCtx.currentTime; const fadeOutTime = 2.0;
        if (this.ambientSources.chaseBass) { this.ambientSources.chaseBass.gain.gain.linearRampToValueAtTime(0, now + fadeOutTime); this.ambientSources.chaseBass.osc.stop(now + fadeOutTime); delete this.ambientSources.chaseBass; }
        if (this.ambientSources.chasePulse) { this.ambientSources.chasePulse.gain.gain.linearRampToValueAtTime(0, now + fadeOutTime); this.ambientSources.chasePulse.osc.stop(now + fadeOutTime); delete this.ambientSources.chasePulse; }
    },
    updateMonsterProximity(distance) {
        if (!this.audioCtx) return;
        const maxDist = 25 * TILE_SIZE;
        if (this.ambientSources.monsterHum) { const vol = Math.max(0, 1 - (distance / maxDist)) * 0.18; this.ambientSources.monsterHum.gain.gain.linearRampToValueAtTime(vol, this.audioCtx.currentTime + 0.1); }
        const proximity = Math.max(0, 1 - (distance / maxDist));
        this.distortionFilter.frequency.linearRampToValueAtTime(22050 - (20000 * proximity), this.audioCtx.currentTime + 0.1);
        if (Game.Monster.isSpawned) {
             this.updateHeartbeat(distance);
        }
    },
    stopAll() { if (!this.audioCtx) return; this.stopHeartbeat(); this.stopChaseGlitchAudio(); this.stopGlitchLoop(); for (const key in this.ambientSources) { try{ this.ambientSources[key].osc.stop(); } catch(e){} } this.ambientSources = {}; this.isChasingMusicPlaying = false; this.stopAmbientSounds(); }
};

// =================================================================================
// MAIN GAME OBJECT
// =================================================================================
const Game = {
    canvas:null, ctx:null, lightCanvas:null, lightCtx:null, fogCanvases:[],
    state:GAME_STATE.TITLE, lastTime:0, deltaTime:0, animationFrame:0, gameOverFrame:0, winFrame:0, killAnimFrame: 0, titleFlickerInterval:null, originalTitle:document.title,
    frozenFrame: null,

    init() {
        this.canvas=document.getElementById('gameCanvas'); this.ctx=this.canvas.getContext('2d');
        this.lightCanvas=document.createElement('canvas'); this.lightCtx=this.lightCanvas.getContext('2d');
        for (let i=0; i<3; i++) { const fc = document.createElement('canvas'); this.fogCanvases.push({ canvas: fc, ctx: fc.getContext('2d'), offset: Math.random() * 1000 }); }
        this.ctx.imageSmoothingEnabled = false; this.lightCtx.imageSmoothingEnabled = false;
        Input.init(); window.addEventListener('resize', ()=>this.resize()); this.resize();
        this.setupInitialListeners(); this.reset();
        requestAnimationFrame(this.loop.bind(this));
    },
    
    setupInitialListeners() { const keyHandler = (e) => { if (this.state === GAME_STATE.TITLE) this.startGame(); if (e.key.toUpperCase() === 'P') this.togglePause(); if (e.key.toUpperCase() === 'R' && (this.state===GAME_STATE.GAME_OVER || this.state===GAME_STATE.WIN)) this.reset(); if (this.state === GAME_STATE.PLAYING && e.key.toUpperCase() === 'F') this.FragmentLocator.activate(this.Player);}; window.addEventListener('keydown', keyHandler); },
    reset() { if(this.titleFlickerInterval) clearInterval(this.titleFlickerInterval); document.title = this.originalTitle; this.Map.generate(); this.Collectibles.generate(); this.LoreItems.generate(); this.RandomEvents.init(); this.GlitchSystem.init(); this.FragmentLocator.init(); this.ShadowFigure.init(); this.Player.init(this.Map.playerStart.x, this.Map.playerStart.y); this.Monster.init(this.Map); this.Camera.init(this.Player); this.Particles.items = []; this.CreepyMessages.items = []; this.UI.activeLoreMessage.timer = 0; this.state = GAME_STATE.TITLE; this.gameOverFrame = 0; this.winFrame = 0; this.killAnimFrame = 0; this.frozenFrame = null; Sound.stopAll(); },
    startGame() { if(this.state === GAME_STATE.TITLE) { Sound.init(); Sound.startMainAmbient(); Sound.startAmbientSounds(); this.state = GAME_STATE.PLAYING; }},
    togglePause() { if(this.state === GAME_STATE.PLAYING) this.state = GAME_STATE.PAUSED; else if(this.state === GAME_STATE.PAUSED) this.state = GAME_STATE.PLAYING; },
    
    loop(timestamp) { this.deltaTime = (timestamp - this.lastTime) / 1000 || 0; this.lastTime = timestamp; this.animationFrame++; this.update(); this.draw(); requestAnimationFrame(this.loop.bind(this)); },
    
    update() {
        if (this.state === GAME_STATE.KILL_ANIMATION) { this.killAnimFrame++; return; }
        if (this.state !== GAME_STATE.PLAYING) {
            if (this.state === GAME_STATE.WIN) this.winFrame++;
            if (this.state === GAME_STATE.GAME_OVER) this.gameOverFrame++;
            return;
        }
        
        this.Player.update(this.deltaTime, this.Map, Input);
        if (this.Monster.isSpawned) this.Monster.update(this.deltaTime, this.Map, this.Player, this);
        this.ShadowFigure.update(this.deltaTime, this.Player, this.Map);
        this.Camera.update(this.Player);
        this.Collectibles.update(this.Player);
        this.LoreItems.update(this.Player);
        this.Particles.update(this.deltaTime);
        this.CreepyMessages.update(this.deltaTime, this.Camera);
        this.RandomEvents.update(this.deltaTime);
        this.GlitchSystem.update(this.deltaTime);
        this.FragmentLocator.update(this.deltaTime, this.Collectibles.items);
        if(this.UI.activeLoreMessage.timer > 0) this.UI.activeLoreMessage.timer -= this.deltaTime;

        if (this.Monster.isSpawned) {
            const dist = Math.hypot(this.Player.x - this.Monster.x, this.Player.y - this.Monster.y);
            Sound.updateMonsterProximity(dist);
        }
        
        if (Math.hypot(this.Player.x - (this.Map.cabinLocation.x * TILE_SIZE), this.Player.y - (this.Map.cabinLocation.y * TILE_SIZE)) < TILE_SIZE * 1.5) {
            if (this.Collectibles.unlocked) {
                if (this.state !== GAME_STATE.WIN) { this.state = GAME_STATE.WIN; Sound.stopAll(); Sound.play('win_whisper'); }
            } else {
                if (this.UI.activeLoreMessage.timer <= 0) {
                    this.UI.showLoreMessage("The door is locked. The fragments call out...", 4);
                }
            }
        }
    },
    
    draw() {
        this.ctx.fillStyle = '#0a0a0f';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        if (this.state === GAME_STATE.TITLE) {
            this.drawTitleScreenBackground();
            this.UI.draw(this.ctx, this);
        } else if (this.state === GAME_STATE.PAUSED || this.state === GAME_STATE.GAME_OVER || this.state === GAME_STATE.WIN) {
            this.UI.draw(this.ctx, this);
        } else if (this.state === GAME_STATE.KILL_ANIMATION) {
            this.drawKillAnimation();
        } else {
            this.ctx.save();
            this.Camera.applyTransform(this.ctx);
            
            this.Map.drawFloor(this.ctx, this.Camera);
            this.Map.bloodDecals.forEach(d => d.draw(this.ctx));
            
            const drawableEntities = [this.Player, ...this.Collectibles.items, ...this.LoreItems.items, ...this.Map.fireflies, ...this.Map.trees, ...this.Map.branches, ...this.Map.deadBodies, this.ShadowFigure];
            drawableEntities.sort((a, b) => (a.y + (a.h||0)) - (b.y + (b.h||0)));
            
            this.Particles.draw(this.ctx, false, true); // Draw footprints underneath entities

            drawableEntities.forEach(entity => {
                if(entity.draw) entity.draw(this.ctx, this.animationFrame, this.Player);
            });
            if (this.Monster.isSpawned) this.Monster.draw(this.ctx, this.animationFrame);

            this.Map.drawCabin(this.ctx, this.animationFrame);
            this.Particles.draw(this.ctx, false, false); // Draw other particles on top
            this.FragmentLocator.draw(this.ctx);
            this.CreepyMessages.draw(this.ctx);
            
            this.ctx.restore();
            
            this.GlitchSystem.applyScreenGlitch(this.ctx);
            if (this.Monster.isSpawned && (this.Monster.state === 'chase' || this.Monster.state === 'FINAL_CHASE')) {
                this.GlitchSystem.applyChaseEffects(this.ctx);
            }
            this.drawFog();
            this.drawLighting();
            this.drawScanlines();
            this.Collectibles.drawPulseGlow(this.ctx, this.Camera);
            this.UI.draw(this.ctx, this);
            this.UI.drawCursor(this.ctx, Input.mouse);
        }
    },

    drawTitleScreenBackground() {
        this.ctx.save();
        this.Camera.x = (MAP_WIDTH * TILE_SIZE - this.Camera.w) / 2 + Math.sin(this.animationFrame * 0.005) * 100;
        this.Camera.y = (MAP_HEIGHT * TILE_SIZE - this.Camera.h) / 2 + Math.cos(this.animationFrame * 0.005) * 100;
        this.Camera.applyTransform(this.ctx);
        this.Map.drawFloor(this.ctx, this.Camera);
        this.Map.trees.forEach(t => t.draw(this.ctx, this.animationFrame));
        this.ctx.restore();
        this.drawFog();
        this.ctx.fillStyle = 'rgba(0,0,0,0.7)';
        this.ctx.fillRect(0,0,this.canvas.width, this.canvas.height);
    },
    
    drawKillAnimation() {
        const frame = this.killAnimFrame;
        const lungeDuration = 10;
        const freezeDuration = 120; // 2 seconds at 60fps
        const totalDuration = lungeDuration + freezeDuration;

        // Phase 1: Lunge
        if (frame < lungeDuration) {
            this.ctx.fillStyle = '#000'; this.ctx.fillRect(0,0, this.canvas.width, this.canvas.height);
            this.ctx.save();
            const progress = frame / lungeDuration;
            const shakeX = (Math.random() - 0.5) * (20 + progress * 80);
            const shakeY = (Math.random() - 0.5) * (20 + progress * 80);
            this.ctx.translate(shakeX, shakeY);
            this.Monster.drawJumpscare(this.ctx, frame * 6);
            this.ctx.restore();
        }
        
        // At the start of Phase 2, capture the frame and start the glitch sound
        if (frame === lungeDuration) {
            this.ctx.fillStyle = '#000'; this.ctx.fillRect(0,0, this.canvas.width, this.canvas.height);
            this.Monster.drawJumpscare(this.ctx, lungeDuration * 6);
            this.frozenFrame = new Image();
            this.frozenFrame.src = this.canvas.toDataURL();
            Sound.play('jumpscare_freeze');
        }

        // Phase 2: Frozen, glitching screen
        if (frame >= lungeDuration && frame < totalDuration) {
            if (this.frozenFrame && this.frozenFrame.complete) {
                this.ctx.drawImage(this.frozenFrame, 0, 0);
            }
            // Apply increasingly intense glitch effects
            const progress = (frame - lungeDuration) / freezeDuration;
            this.applyHardGlitch(this.ctx, progress);
        }
    
        // Transition to game over screen
        if (frame >= totalDuration) {
            Sound.stopGlitchLoop();
            this.state = GAME_STATE.GAME_OVER;
        }
    },

    applyHardGlitch(ctx, progress) {
        // Data moshing / screen tear effect
        for (let i = 0; i < Math.floor(progress * 15); i++) {
            const x = Math.random() * ctx.canvas.width;
            const y = Math.random() * ctx.canvas.height;
            const w = (Math.random() * 200 + 50) * progress;
            const h = Math.random() * 15 + 1;
            const x2 = x + (Math.random() - 0.5) * 50 * progress;
            const y2 = y;
            if(x2>0 && y2>0 && w>0 && h>0 && x2+w < ctx.canvas.width && y2+h < ctx.canvas.height){
               ctx.drawImage(ctx.canvas, x, y, w, h, x2, y2, w, h);
            }
        }
        // Chromatic Aberration
        const offset = progress * 20;
        ctx.globalCompositeOperation = 'lighter';
        ctx.drawImage(ctx.canvas, offset, 0);
        ctx.fillStyle = `rgba(255,0,0,${0.2 * progress})`; ctx.fillRect(0,0,ctx.canvas.width, ctx.canvas.height);
        ctx.drawImage(ctx.canvas, -offset, 0);
        ctx.fillStyle = `rgba(0,0,255,${0.2 * progress})`; ctx.fillRect(0,0,ctx.canvas.width, ctx.canvas.height);
        ctx.globalCompositeOperation = 'source-over';
    },
    
    drawScanlines() {
        this.ctx.globalAlpha = 0.1;
        this.ctx.fillStyle = '#000';
        for (let y = 0; y < this.canvas.height; y += 3) {
            this.ctx.fillRect(0, y, this.canvas.width, 1);
        }
        this.ctx.globalAlpha = 1.0;
    },

    drawFog() { this.fogCanvases.forEach((fog, index) => { const parallax = 0.2 * (index + 1); const x = -this.Camera.x * parallax; const y = -this.Camera.y * parallax; fog.ctx.globalCompositeOperation = 'source-over'; fog.ctx.clearRect(0,0,fog.canvas.width,fog.canvas.height); fog.ctx.globalCompositeOperation = 'lighter'; for (let i = 0; i < 5 + index * 5; i++) { const fx = (Math.sin(this.animationFrame * 0.0005 * i + fog.offset) * fog.canvas.width*0.7 + fog.canvas.width/2 + x) % fog.canvas.width; const fy = (Math.cos(this.animationFrame * 0.0007 * i + fog.offset + i*10) * fog.canvas.height*0.7 + fog.canvas.height/2 + y) % fog.canvas.height; const radius = 150 + Math.sin(i) * 50; const grad = fog.ctx.createRadialGradient(fx, fy, 0, fx, fy, radius); grad.addColorStop(0, `rgba(25, 30, 45, ${0.03 * (3-index)})`); grad.addColorStop(1, 'rgba(25, 30, 45, 0)'); fog.ctx.fillStyle = grad; fog.ctx.fillRect(fx - radius, fy - radius, radius * 2, radius * 2); } this.ctx.globalAlpha = 0.8; this.ctx.drawImage(fog.canvas, 0, 0); this.ctx.globalAlpha = 1; }); },
    drawLighting() {
        const lCtx = this.lightCanvas.getContext('2d');
        lCtx.clearRect(0,0,this.lightCanvas.width,this.lightCanvas.height);
        lCtx.fillStyle = 'rgba(0,0,10,0.97)';
        lCtx.fillRect(0,0,this.lightCanvas.width,this.lightCanvas.height);
        lCtx.save();
        lCtx.globalCompositeOperation='destination-out';
        
        let lightRadius = (280 * (1+(Math.random()-0.5)*0.1)) * this.RandomEvents.getFlashlightModifier();
        const lSX = this.Player.lightSource.x - this.Camera.x;
        const lSY = this.Player.lightSource.y - this.Camera.y;
        const angle = this.Player.lightAngle;
        
        const mainGradient=lCtx.createRadialGradient(lSX,lSY,0,lSX,lSY,lightRadius); mainGradient.addColorStop(0,'rgba(255,255,230,1)'); mainGradient.addColorStop(0.1,'rgba(255,255,230,0.8)'); mainGradient.addColorStop(1,'rgba(255,255,230,0)'); lCtx.beginPath();lCtx.moveTo(lSX,lSY);lCtx.arc(lSX,lSY,lightRadius,angle-Math.PI/4.5,angle+Math.PI/4.5);lCtx.closePath();lCtx.fillStyle=mainGradient;lCtx.fill();
        
        const pSX = this.Player.x - this.Camera.x + this.Player.w / 2;
        const pSY = this.Player.y - this.Camera.y + this.Player.h / 2;
        const bounceGradient=lCtx.createRadialGradient(pSX,pSY,0,pSX,pSY,TILE_SIZE*2.5 * this.RandomEvents.getFlashlightModifier()); bounceGradient.addColorStop(0,'rgba(255,255,230,0.25)'); bounceGradient.addColorStop(1,'rgba(255,255,230,0)'); lCtx.fillStyle=bounceGradient;lCtx.beginPath();lCtx.arc(pSX,pSY,TILE_SIZE*2.5,0,Math.PI*2);lCtx.fill();
        
        lCtx.restore(); this.ctx.drawImage(this.lightCanvas,0,0);
        
        const vigGrad = this.ctx.createRadialGradient(this.canvas.width/2,this.canvas.height/2,this.canvas.height/2,this.canvas.width/2,this.canvas.height/2,this.canvas.width/1.5);
        vigGrad.addColorStop(0,'rgba(0,0,0,0)'); vigGrad.addColorStop(1,'rgba(0,0,0,0.4)'); this.ctx.fillStyle=vigGrad; this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height);
    },
    
    gameOver() {
        if (this.state === GAME_STATE.PLAYING) {
            this.state = GAME_STATE.KILL_ANIMATION;
            this.killAnimFrame = 0;
            Sound.play('kill_sequence');
            Sound.stopAll();
        }
    },
    
    resize() { const r=16/9; let nW=window.innerWidth,nH=window.innerHeight; if(nH/nW>1/r)nH=nW/r;else nW=nH*r; this.canvas.width=1280;this.canvas.height=720; this.canvas.style.width=`${nW}px`;this.canvas.style.height=`${nH}px`; this.lightCanvas.width=this.canvas.width;this.lightCanvas.height=this.canvas.height;this.fogCanvases.forEach(f=>{f.canvas.width=this.canvas.width;f.canvas.height=this.canvas.height;}); },
    
    Map: {
        tiles:[],trees:[],fireflies:[],branches:[],deadBodies:[],bloodDecals:[],cabinLocation:{x:0,y:0},playerStart:{x:0,y:0},
        generate() {
            this.tiles = Array.from({length: MAP_HEIGHT}, () => Array(MAP_WIDTH).fill(1));
            this.trees = []; this.fireflies = []; this.branches = []; this.deadBodies = []; this.bloodDecals = [];
            
            let walkers = [{x: Math.floor(MAP_WIDTH / 2), y: Math.floor(MAP_HEIGHT / 2)}];
            for (let i = 0; i < 9000; i++) {
                const w = walkers[Math.floor(Math.random() * walkers.length)];
                const dir = Math.floor(Math.random() * 4);
                if (dir === 0 && w.x < MAP_WIDTH - 2) w.x++; if (dir === 1 && w.x > 1) w.x--;
                if (dir === 2 && w.y < MAP_HEIGHT - 2) w.y++; if (dir === 3 && w.y > 1) w.y--;
                if (w.y >= 0 && w.y < MAP_HEIGHT && w.x >= 0 && w.x < MAP_WIDTH) {
                    this.tiles[w.y][w.x] = 0;
                    if (Math.random() > 0.96 && walkers.length < 12) walkers.push({...w});
                }
            }
            const mainArea = this.placeConnectedFeatures();

            for(let i=0; i < 7; i++){ 
                const pos = mainArea[Math.floor(Math.random()*mainArea.length)];
                const bodyX = pos.x * TILE_SIZE + Math.random() * TILE_SIZE;
                const bodyY = pos.y * TILE_SIZE + Math.random() * TILE_SIZE;
                
                // --- Create Blood Decal ---
                const bloodShapes = []; const numPoolShapes = 4 + Math.floor(Math.random() * 4);
                for (let j = 0; j < numPoolShapes; j++) { bloodShapes.push({ dx: (Math.random() - 0.5) * 20, dy: (Math.random() - 0.5) * 20, radX: 5 + Math.random() * 15, radY: 5 + Math.random() * 15, angle: Math.random() * Math.PI }); }
                const bloodSplatters = []; const numSplatters = 8 + Math.floor(Math.random() * 12);
                for (let j = 0; j < numSplatters; j++) { const dist = 25 + Math.random() * 35; const angle = Math.random() * Math.PI * 2; bloodSplatters.push({ dx: Math.cos(angle) * dist, dy: Math.sin(angle) * dist, size: 2 + Math.random() * 3 }); }
                
                this.bloodDecals.push({
                    x: bodyX, y: bodyY, shapes: bloodShapes, splatters: bloodSplatters,
                    draw: function(ctx){
                        ctx.save(); ctx.translate(this.x, this.y);
                        const colors = ['#400a0f', '#5e0b15'];
                        this.shapes.forEach((s, idx) => {
                            ctx.fillStyle = colors[idx % colors.length]; ctx.beginPath(); ctx.ellipse(s.dx, s.dy, s.radX, s.radY, s.angle, 0, Math.PI * 2); ctx.fill();
                        });
                        ctx.fillStyle = '#900c3f';
                        this.splatters.forEach(s => { ctx.fillRect(s.dx, s.dy, s.size, s.size); });
                        ctx.restore();
                    }
                });

                // --- Create Body ---
                this.deadBodies.push({ 
                    x: bodyX, y: bodyY, w: 24, h: 12, angle: Math.random() * Math.PI * 2,
                    draw: function(ctx){
                        ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
                        ctx.fillStyle='#5a3a3a';ctx.fillRect(-12,-4,24,8);
                        ctx.fillStyle='#4a2a2a';ctx.fillRect(-4,-10,8,6);ctx.fillRect(10,-10,4,12);ctx.fillRect(-15,5,4,12);
                        ctx.restore();
                    }
                }); 
            }

            for(let i=0;i<120;i++){const x=Math.floor(Math.random()*MAP_WIDTH),y=Math.floor(Math.random()*MAP_HEIGHT);if(this.isWalkable(x,y))this.tiles[y][x]=2;}
            for(let i=0;i<15;i++){const x=Math.floor(Math.random()*MAP_WIDTH),y=Math.floor(Math.random()*MAP_HEIGHT);if(this.isWalkable(x,y)){this.branches.push({x:x*TILE_SIZE+TILE_SIZE/2,y:y*TILE_SIZE+TILE_SIZE/2,w:20,h:20,
                draw: function(ctx) { ctx.fillStyle='#543a28'; ctx.beginPath(); ctx.moveTo(this.x-10, this.y); ctx.lineTo(this.x, this.y+10); ctx.lineTo(this.x+10, this.y-5); ctx.closePath(); ctx.fill();}
            });}}
            for(let i=0;i<30;i++){this.fireflies.push({x:Math.random()*MAP_WIDTH*TILE_SIZE,y:Math.random()*MAP_HEIGHT*TILE_SIZE,w:3,h:3,offset:Math.random()*1000,draw:function(ctx,frame){const alpha=Math.abs(Math.sin(frame*0.05+this.offset));ctx.fillStyle=`rgba(200,255,180,${alpha})`;ctx.shadowColor='#aff';ctx.shadowBlur=10;ctx.fillRect(this.x,this.y,this.w,this.h);ctx.shadowBlur=0;}});}
            for(let y=0;y<MAP_HEIGHT;y++){for(let x=0;x<MAP_WIDTH;x++){if(this.tiles[y][x]===1){const type=Math.random();const hueShift=(Math.random()-0.5)*10;const satShift=Math.random()*20;const lightShift=(Math.random()-0.5)*10;this.trees.push({x:x*TILE_SIZE,y:y*TILE_SIZE,w:TILE_SIZE,h:TILE_SIZE,type:type,sway:Math.random()*Math.PI*2,color:`hsl(${100+hueShift},${30+satShift}%,${15+lightShift}%)`,draw:function(ctx,frame,player){const sX=Math.sin(frame*0.02+this.sway)*4;ctx.fillStyle='#3a2d27';ctx.fillRect(this.x+12+sX/2,this.y-TILE_SIZE,8,TILE_SIZE*1.5);if(this.type>0.9)ctx.fillRect(this.x-5+sX/2,this.y-10,20,4);let foliageAlpha=1.0;if(player){const dist=Math.hypot((player.x+player.w/2)-(this.x+this.w/2),(player.y+player.h/2)-(this.y-this.h/2));const maxDist=TILE_SIZE*2.5;if(dist<maxDist)foliageAlpha=Math.max(0.3,dist/maxDist);}ctx.globalAlpha=foliageAlpha;ctx.fillStyle=this.color;ctx.beginPath();ctx.ellipse(this.x+16+sX,this.y-TILE_SIZE/2,this.type>0.7?20:24,32,0,0,Math.PI*2);ctx.fill();ctx.globalAlpha=1.0;if(Math.random()<0.003&&foliageAlpha>0.9&&Game.state===GAME_STATE.PLAYING){Game.Particles.create(this.x+Math.random()*this.w, this.y, 1, 'leaf', 2, 15, 0);}}});}}}
        },
        placeConnectedFeatures() {
            const visited = new Set(); let largestArea = [];
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    const key = `${x},${y}`;
                    if (this.isWalkable(x, y) && !visited.has(key)) {
                        const currentArea = []; const queue = [{x, y}]; visited.add(key);
                        while (queue.length > 0) {
                            const current = queue.shift(); currentArea.push(current);
                            const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                            for (const [dx, dy] of dirs) {
                                const nx = current.x + dx, ny = current.y + dy; const nKey = `${nx},${ny}`;
                                if (this.isWalkable(nx, ny) && !visited.has(nKey)) { visited.add(nKey); queue.push({x: nx, y: ny}); }
                            }
                        }
                        if (currentArea.length > largestArea.length) { largestArea = currentArea; }
                    }
                }
            }
            const playerSpots = largestArea.filter(p => p.y > MAP_HEIGHT * 0.8);
            this.playerStart = playerSpots.length > 0 ? playerSpots[Math.floor(Math.random() * playerSpots.length)] : largestArea[largestArea.length - 1];
            const cabinSpots = largestArea.filter(p => p.y < MAP_HEIGHT * 0.2);
            this.cabinLocation = cabinSpots.length > 0 ? cabinSpots[Math.floor(Math.random() * cabinSpots.length)] : largestArea[0];
            this.tiles[this.cabinLocation.y][this.cabinLocation.x] = 3;
            return largestArea;
        },
        isWalkable(tX, tY, forMonster = false) {
            if (tX < 0 || tX >= MAP_WIDTH || tY < 0 || tY >= MAP_HEIGHT) return false;
            if (!this.tiles || !this.tiles[tY] || this.tiles[tY][tX] === undefined) return false;
            const tile = this.tiles[tY][tX];
            if (tile === 1) return false;
            if (forMonster && tile === 3) return false;
            return true;
        },
        drawFloor(ctx,cam){const sC=Math.floor(cam.x/TILE_SIZE),eC=sC+Math.ceil(cam.w/TILE_SIZE)+1,sR=Math.floor(cam.y/TILE_SIZE),eR=sR+Math.ceil(cam.h/TILE_SIZE)+1;for(let y=sR;y<eR;y++){for(let x=sC;x<eC;x++){if(x<0||x>=MAP_WIDTH||y<0||y>=MAP_HEIGHT)continue;const t=this.tiles[y][x],tX=x*TILE_SIZE,tY=y*TILE_SIZE;ctx.fillStyle='#2b2118';ctx.fillRect(tX,tY,TILE_SIZE,TILE_SIZE);if(t===0||t===3){ctx.fillStyle=`#4a4137`;ctx.fillRect(tX,tY,TILE_SIZE,TILE_SIZE);if(Math.sin(x*y*0.1)>0.8)ctx.fillStyle=`rgba(0,0,0,0.05)`;ctx.fillRect(tX,tY,TILE_SIZE,TILE_SIZE);}else if(t===2){ctx.fillStyle='#4a4137';ctx.fillRect(tX,tY,TILE_SIZE,TILE_SIZE);ctx.fillStyle='#4a4a4f';ctx.beginPath();ctx.moveTo(tX+5,tY+TILE_SIZE-5);ctx.lineTo(tX+10,tY+5);ctx.lineTo(tX+TILE_SIZE-8,tY+8);ctx.lineTo(tX+TILE_SIZE-5,tY+TILE_SIZE-10);ctx.closePath();ctx.fill();}}}},
        drawCabin(ctx,frame){const cX=this.cabinLocation.x*TILE_SIZE,cY=this.cabinLocation.y*TILE_SIZE;ctx.fillStyle='#4f3a2d';ctx.fillRect(cX-TILE_SIZE/2,cY-TILE_SIZE,TILE_SIZE*2,TILE_SIZE*1.5);ctx.fillStyle='#2c211a';ctx.beginPath();ctx.moveTo(cX-TILE_SIZE/2,cY-TILE_SIZE);ctx.lineTo(cX+TILE_SIZE/2,cY-TILE_SIZE*2);ctx.lineTo(cX+TILE_SIZE*2.5-TILE_SIZE/2,cY-TILE_SIZE);ctx.closePath();ctx.fill();const f=0.8+Math.sin(frame*0.15)*0.2+(Math.random()-0.5)*0.1;ctx.shadowColor = '#aff'; ctx.shadowBlur = 20 * f;ctx.fillStyle=`rgba(180,255,180,${f})`;ctx.fillRect(cX+TILE_SIZE/2,cY-TILE_SIZE/2,TILE_SIZE*0.6,TILE_SIZE*0.5);ctx.shadowBlur=0;}},
    
    Player:{x:0,y:0,w:16,h:24,speed:110,sprintSpeed:175,lightAngle:0,moveAngle:0,isMoving:false,isSprinting:false,animFrame:0,footstepTimer:0,stamina:100,maxStamina:100, lightSource: {x:0, y:0}, bloodyFootprints: 0,
        init(sX,sY){this.x=sX*TILE_SIZE+TILE_SIZE/2-this.w/2;this.y=sY*TILE_SIZE+TILE_SIZE/2-this.h/2;this.isMoving=false;this.stamina=this.maxStamina; this.lightSource = { x: this.x, y: this.y }; this.bloodyFootprints = 0;},
        update(dt,map,input){
            let dX=0, dY=0;
            this.isMoving=false;
            this.isSprinting=input.isDown('SHIFT')&&this.stamina>0;
            const currentSpeed=this.isSprinting?this.sprintSpeed:this.speed;
            if(this.isSprinting)this.stamina=Math.max(0,this.stamina-25*dt);else if(this.stamina<this.maxStamina)this.stamina=Math.min(this.maxStamina,this.stamina+15*dt);

            if(input.isDown('W')||input.isDown('ArrowUp')) dY-=1;
            if(input.isDown('S')||input.isDown('ArrowDown')) dY+=1;
            if(input.isDown('A')||input.isDown('ArrowLeft')) dX-=1;
            if(input.isDown('D')||input.isDown('ArrowRight')) dX+=1;
        
            if(dX !== 0 || dY !== 0){
                this.isMoving=true; this.animFrame+=dt*(this.isSprinting?12:8); this.footstepTimer-=dt;
                this.moveAngle = Math.atan2(dY, dX);
                
                const mag = Math.sqrt(dX * dX + dY * dY); let moveX = 0, moveY = 0;
                if (mag > 0) { moveX = (dX / mag) * currentSpeed * dt; moveY = (dY / mag) * currentSpeed * dt; }
                
                let nextX = this.x + moveX; let nextY = this.y + moveY;
                const pTileX = Math.floor((this.x + this.w / 2) / TILE_SIZE); const pTileY = Math.floor((this.y + this.h) / TILE_SIZE);
                if (map.isWalkable(Math.floor((nextX + this.w / 2) / TILE_SIZE), pTileY)) this.x = nextX;
                if (map.isWalkable(pTileX, Math.floor((nextY + this.h) / TILE_SIZE))) this.y = nextY;
            } else { this.animFrame+=dt*2; }
            
            let isOverBlood = false;
            for(const decal of map.bloodDecals){ if(Math.hypot(this.x-decal.x, this.y-decal.y) < TILE_SIZE * 1.2) { isOverBlood = true; break; } }
            if(isOverBlood) this.bloodyFootprints = 20;

            if (this.isMoving && this.footstepTimer <= 0) {
                this.footstepTimer = this.isSprinting ? 0.25 : 0.35;
                if(this.bloodyFootprints > 0) {
                    Sound.play('blood_step');
                    Game.Particles.create(this.x + this.w/2, this.y + this.h - 5, 1, 'blood_footprint', 3.0, 0, this.moveAngle + Math.PI/2);
                    this.bloodyFootprints--;
                } else {
                    Sound.play('footstep');
                }
            }

            map.branches = map.branches.filter(branch => {
                if (Math.hypot(this.x + this.w/2 - branch.x, this.y + this.h/2 - branch.y) < TILE_SIZE/2) {
                    Sound.play('branch_snap');
                    Game.Monster.alert(branch.x, branch.y);
                    return false;
                }
                return true;
            });

            const pSX=this.x-Game.Camera.x+this.w/2,pSY=this.y-Game.Camera.y+this.h/2; this.lightAngle=Math.atan2(Input.mouse.y-pSY,Input.mouse.x-pSX);
            const pivotX = this.x + this.w / 2, pivotY = this.y + this.h / 2 - 4, lightOffset = 18;
            this.lightSource.x = pivotX + lightOffset * Math.cos(this.lightAngle);
            this.lightSource.y = pivotY + lightOffset * Math.sin(this.lightAngle);
        },
        draw(ctx,frame){const bob=Math.sin(this.animFrame)*(this.isMoving?2:1);ctx.save();ctx.translate(this.x,this.y+bob);ctx.fillStyle='rgba(0,0,0,0.2)';ctx.beginPath();ctx.ellipse(this.w/2,this.h-2,this.w/2.5,4,0,0,Math.PI*2);ctx.fill();ctx.fillStyle='#a0a0b0';ctx.fillRect(this.w/2-5,0,10,16);ctx.fillStyle='#d0d0e0';ctx.fillRect(this.w/2-4,-8,8,8);const legOffset=this.isMoving?Math.sin(this.animFrame*2)*3:0;ctx.fillStyle='#606070';ctx.fillRect(this.w/2-5,16,4,8-legOffset);ctx.fillRect(this.w/2+1,16,4,8+legOffset);
        ctx.save();ctx.translate(this.w/2,this.h/2-4);ctx.rotate(this.lightAngle);ctx.fillStyle='#808090';ctx.fillRect(0,-2,12,4);ctx.fillStyle='#333';ctx.fillRect(10,-3,8,6);ctx.fillStyle='#111';ctx.fillRect(12,-2,2,4);ctx.restore();
        ctx.restore();},},
    
    Monster:{
        x:0,y:0,w:48,h:64,state:'patrol',dir:{x:0,y:1},visionRange:350,visionAngle:Math.PI/2.5,lastKnownPos:null,stateTimer:0, motes: [], isSpawned: false,
        init(map){
            this.motes = [];
            for (let i = 0; i < 70; i++) { this.motes.push({ angle: Math.random() * Math.PI * 2, radius: 10 + Math.random() * 25, speed: 0.5 + Math.random() * 1.5, size: 2 + Math.random() * 6 }); }
            let p=false; let attempts=0;
            while(!p && attempts < 200){
                attempts++;
                // Pick a random top-left corner for a 2x2 tile area, ensuring it's not on the far edge of the map.
                const x = Math.floor(Math.random() * (MAP_WIDTH - 1));
                const y = Math.floor(Math.random() * (MAP_HEIGHT - 1));

                // The monster is large (w:48, h:64 on 32px tiles), so we need to check a 2x2 area
                // to make sure it doesn't spawn partially inside a tree and get stuck.
                const areaIsClear = map.isWalkable(x, y, true) &&
                                      map.isWalkable(x + 1, y, true) &&
                                      map.isWalkable(x, y + 1, true) &&
                                      map.isWalkable(x + 1, y + 1, true);

                if (areaIsClear && Math.hypot(x - map.playerStart.x, y - map.playerStart.y) > 30) {
                    this.x = x * TILE_SIZE;
                    this.y = y * TILE_SIZE;
                    p = true;
                }
            }
            if(!p){this.x=TILE_SIZE*5; this.y=TILE_SIZE*5; console.warn("Failsafe monster placement used.");} this.state='patrol';this.lastKnownPos=null;this.stateTimer=0; this.isSpawned = false;
        },
        alert(x, y) {
            if (this.state !== 'chase' && this.state !== 'FINAL_CHASE' && this.isSpawned) {
                this.state = 'search';
                this.lastKnownPos = { x, y };
                this.stateTimer = 8;
            }
        },
        triggerFinalChase() {
            if (this.state !== 'FINAL_CHASE') {
                this.state = 'FINAL_CHASE';
                Sound.startChaseMusic(true);
                Sound.startChaseGlitchAudio();
            }
        },
        update(dt,map,player,game){
            this.stateTimer-=dt;
            if(this.state !== 'FINAL_CHASE' && this.canSeePlayer(player,map)){
                if(this.state!=='chase') {
                    Sound.startChaseMusic(false);
                    Sound.startChaseGlitchAudio();
                }
                this.state='chase';
                this.stateTimer=4;
                this.lastKnownPos={x:player.x,y:player.y};
            }
            else if(this.state==='chase'&&this.stateTimer<=0){
                Sound.stopChaseMusic();
                Sound.stopChaseGlitchAudio();
                this.state='search';
                this.stateTimer=6;
            }
            
            let speed = 0;
            switch(this.state){
                case 'patrol': speed=65;if(this.stateTimer<=0){this.findNewPatrolDirection(map);this.stateTimer=Math.random()*5+5;} break;
                case 'chase': speed=155;if(this.lastKnownPos){const dX=this.lastKnownPos.x-this.x,dY=this.lastKnownPos.y-this.y;const dist=Math.hypot(dX,dY);if (dist > 0) this.dir={x:dX/dist,y:dY/dist};} break;
                case 'search': speed=80;if(this.stateTimer>3&&this.lastKnownPos){const dX=this.lastKnownPos.x-this.x,dY=this.lastKnownPos.y-this.y;const dist=Math.hypot(dX,dY);if(dist>TILE_SIZE){this.dir={x:dX/dist,y:dY/dist};}else{this.stateTimer=3;}}else if(this.stateTimer>0){if(game.animationFrame%40===0){const angle=Math.random()*Math.PI*2;this.dir={x:Math.cos(angle),y:Math.sin(angle)};}}else{this.state='patrol';this.stateTimer=Math.random()*5+5;} break;
                case 'FINAL_CHASE': speed = 180; const dX = player.x - this.x, dY = player.y - this.y; const dist = Math.hypot(dX, dY); if (dist > 0) this.dir = {x: dX / dist, y: dY / dist}; break;
            }

            if (speed > 0) {
                let moveX = this.dir.x * speed * dt;
                let moveY = this.dir.y * speed * dt;
                let nextX = this.x + moveX;
                let nextY = this.y + moveY;
                const checkTileX = Math.floor((this.x + this.w / 2) / TILE_SIZE);
                const checkTileY = Math.floor((this.y + this.h) / TILE_SIZE);
                if (map.isWalkable(Math.floor((nextX + this.w / 2) / TILE_SIZE), checkTileY, true)) { this.x = nextX; }
                if (map.isWalkable(checkTileX, Math.floor((nextY + this.h) / TILE_SIZE), true)) { this.y = nextY; }
                this.x = Math.max(0, Math.min(this.x, MAP_WIDTH * TILE_SIZE - this.w));
                this.y = Math.max(0, Math.min(this.y, MAP_HEIGHT * TILE_SIZE - this.h));
            }

            if(Math.hypot(this.x + this.w/2 - (player.x + player.w/2), this.y + this.h/2 - (player.y + player.h/2)) < TILE_SIZE * 0.8)game.gameOver();
            const chaseFactor = (this.state === 'chase' || this.state === 'FINAL_CHASE') ? 3 : 1;
            this.motes.forEach(mote => { mote.angle += mote.speed * dt * chaseFactor; });
        },
        findNewPatrolDirection(map){const pD=[{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}];let vD=[];for(const d of pD){const cX=Math.floor((this.x+this.w/2+d.x*TILE_SIZE*2)/TILE_SIZE),cY=Math.floor((this.y+this.h/2+d.y*TILE_SIZE*2)/TILE_SIZE);if(map.isWalkable(cX,cY,true))vD.push(d);}if(vD.length>0)this.dir=vD[Math.floor(Math.random()*vD.length)];},
        canSeePlayer(player,map){const dX=player.x-this.x,dY=player.y-this.y,dist=Math.hypot(dX,dY);if(dist>this.visionRange)return false;const angleToPlayer=Math.atan2(dY,dX),monsterAngle=Math.atan2(this.dir.y,this.dir.x);let angleDiff=Math.abs(monsterAngle-angleToPlayer);if(angleDiff>Math.PI)angleDiff=2*Math.PI-angleDiff;if(angleDiff>this.visionAngle/2)return false;for(let i=0;i<dist;i+=TILE_SIZE/2){const cX=this.x+(dX/dist)*i,cY=this.y+(dY/dist)*i;const cTileX = Math.floor(cX/TILE_SIZE); const cTileY = Math.floor(cY/TILE_SIZE); if (!map.isWalkable(cTileX, cTileY, true)) return false;}return true;},
        draw(ctx,frame){
            const isChasing = this.state === 'chase' || this.state === 'FINAL_CHASE';
            const centerX = this.x + this.w / 2, centerY = this.y + this.h / 2;
            ctx.save();
            ctx.translate(centerX, centerY);
            
            this.motes.forEach(mote => {
                const chaseFactor = isChasing ? 1 + Math.sin(frame * 5 + mote.angle) * 0.8 : 1;
                const r = mote.radius * chaseFactor;
                const x = Math.cos(mote.angle) * r;
                const y = Math.sin(mote.angle) * r;
                const size = mote.size * (isChasing ? 1.5 : 1);
                ctx.fillStyle = `rgba(10, 3, 3, ${0.5 + Math.random() * 0.5})`;
                ctx.fillRect(x - size/2, y - size/2, size, size);
            });
            
            const eyeColor = isChasing ? '#ff2020' : '#ccffcc';
            const pulse = isChasing ? 1 + Math.abs(Math.sin(frame * 0.5)) * 0.5 : 1;
            const eyeSize = (isChasing ? 8 : 6) * pulse;
            ctx.fillStyle = eyeColor; ctx.shadowColor = eyeColor; ctx.shadowBlur = 20;
            ctx.fillRect(-12 - eyeSize/2, -5, eyeSize, eyeSize);
            ctx.fillRect(12 - eyeSize/2, -5, eyeSize, eyeSize);
            ctx.shadowBlur = 0;

            ctx.restore();
        },
        drawJumpscare(ctx,frame){const size=Math.min(ctx.canvas.width,ctx.canvas.height)*1.8*Math.min(1,frame/30);const x=ctx.canvas.width/2-size/2,y=ctx.canvas.height/2-size/2;ctx.save();ctx.translate(x,y);ctx.fillStyle='#111';ctx.fillRect(0,0,size,size);ctx.fillStyle='#ff0000';const eyeSize=size*0.2,eyeY=size*0.3,eyeLX=size*0.25,eyeRX=size*0.75;ctx.globalAlpha=0.8+Math.random()*0.2;ctx.fillRect(eyeLX-eyeSize/2,eyeY-eyeSize/2,eyeSize,eyeSize);ctx.fillRect(eyeRX-eyeSize/2,eyeY-eyeSize/2,eyeSize,eyeSize);ctx.restore();}
    },

    ShadowFigure: {
        x: 0, y: 0, w: 16, h: 24, active: false, state: 'lurking', spawnTimer: 20,
        animFrame: 0, footstepTimer: 0, fleeTimer: 0,
        init() { this.active = false; this.spawnTimer = 15 + Math.random() * 10; },
        update(dt, player, map) {
            if (!this.active) {
                this.spawnTimer -= dt;
                if (this.spawnTimer <= 0) { this.trySpawn(player, map); this.spawnTimer = 25 + Math.random() * 15; }
                return;
            }

            const distToPlayer = Math.hypot(this.x - player.x, this.y - player.y);

            if (this.state === 'lurking' && distToPlayer < 200) {
                this.state = 'fleeing';
                this.fleeTimer = 4.0; // Flee for 4 seconds
            }

            if (this.state === 'fleeing') {
                this.fleeTimer -= dt;
                this.animFrame += dt * 10;
                this.footstepTimer -= dt;
                if (this.footstepTimer <= 0) {
                    Sound.play('clone_footstep');
                    this.footstepTimer = 0.28;
                }

                if (this.fleeTimer <= 0) {
                    this.active = false;
                    return;
                }

                // Flee logic
                const fleeSpeed = 150;
                const fleeDX = this.x - player.x;
                const fleeDY = this.y - player.y;
                const mag = Math.hypot(fleeDX, fleeDY);
                
                let moveX = (fleeDX / mag) * fleeSpeed * dt;
                let moveY = (fleeDY / mag) * fleeSpeed * dt;

                let nextX = this.x + moveX; let nextY = this.y + moveY;
                const cTileX = Math.floor((this.x + this.w / 2) / TILE_SIZE);
                const cTileY = Math.floor((this.y + this.h) / TILE_SIZE);
                if (map.isWalkable(Math.floor((nextX + this.w / 2) / TILE_SIZE), cTileY)) this.x = nextX;
                if (map.isWalkable(cTileX, Math.floor((nextY + this.h) / TILE_SIZE))) this.y = nextY;
            }
        },
        trySpawn(player, map) {
            // Try to spawn at the edge of the screen, on a path
            const spawnAngle = player.lightAngle + (Math.random() - 0.5) * 1.0; // In front of player
            const spawnDist = 350 + Math.random() * 100;
            const pX = player.x + Math.cos(spawnAngle) * spawnDist; 
            const pY = player.y + Math.sin(spawnAngle) * spawnDist;
            const tX = Math.floor(pX / TILE_SIZE); const tY = Math.floor(pY / TILE_SIZE);
            if (map.isWalkable(tX,tY)) { 
                this.x = pX; this.y = pY; this.active = true; this.state = 'lurking'; 
                this.animFrame = 0; this.footstepTimer = 0;
            }
        },
        draw(ctx) {
            if (!this.active) return;
            const isMoving = this.state === 'fleeing';
            const bob = Math.sin(this.animFrame) * (isMoving ? 2 : 0);
            ctx.save();
            ctx.translate(this.x, this.y + bob);
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath();ctx.ellipse(this.w/2,this.h-2,this.w/2.5,4,0,0,Math.PI*2);ctx.fill();
            ctx.fillStyle = '#666'; ctx.fillRect(this.w/2 - 5, 0, 10, 16); // Torso
            ctx.fillStyle = '#888'; ctx.fillRect(this.w/2 - 4, -8, 8, 8); // Head
            const legOffset = isMoving ? Math.sin(this.animFrame * 2) * 3 : 0;
            ctx.fillStyle = '#444'; // Legs
            ctx.fillRect(this.w/2 - 5, 16, 4, 8 - legOffset);
            ctx.fillRect(this.w/2 + 1, 16, 4, 8 + legOffset);
            ctx.restore();
        }
    },
    
    Collectibles:{items:[],score:0,totalItems:0,unlocked:false,
        generate(){this.items=[];this.score=0;this.unlocked=false;this.totalItems=10;for(let i=0;i<this.totalItems;i++){let p=false;let attempts=0;while(!p && attempts < 100){attempts++;const x=Math.floor(Math.random()*MAP_WIDTH),y=Math.floor(Math.random()*MAP_HEIGHT);if(Game.Map.isWalkable(x,y)&&Math.hypot(x-Game.Map.playerStart.x,y-Game.Map.playerStart.y)>15){this.items.push({x:x*TILE_SIZE+TILE_SIZE/2-4,y:y*TILE_SIZE+TILE_SIZE/2-4,w:8,h:8,pulseOffset:Math.random()*Math.PI,pulseTimer:0,
            draw:function(ctx,frame){
                let p=0.7+Math.sin(frame*0.1+this.pulseOffset)*0.3;
                ctx.globalAlpha = 1;
                ctx.fillStyle=`rgba(200,220,255,${p*0.5+0.5})`;
                ctx.shadowColor='rgba(180,200,255,1)'; ctx.shadowBlur= 20;
                ctx.fillRect(this.x,this.y,this.w,this.h);
                ctx.shadowBlur=0;
            }
        });p=true;}}}},
        update(player){
            this.items.forEach(item => { if(item.pulseTimer > 0) item.pulseTimer -= Game.deltaTime; });
            this.items = this.items.filter(item => {
                if(Math.hypot(player.x - item.x, player.y - item.y) < TILE_SIZE/1.5){
                    this.score++; Sound.play('collectible'); Game.Particles.create(item.x + item.w/2, item.y + item.h/2, 25, '200, 220, 255', 0.8, 60, 0);
                    if(this.score === 4 && !Game.Monster.isSpawned) {
                        Game.Monster.isSpawned = true;
                        Sound.startHeartbeat();
                        Game.UI.showLoreMessage("The air grows cold. You are not alone.", 5);
                    }
                    if(this.score >= this.totalItems && !this.unlocked) { this.unlocked = true; Game.Monster.triggerFinalChase(); }
                    return false;
                }
                return true;
            });
        },
        drawPulseGlow(ctx, camera) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            this.items.forEach(item => {
                if (item.pulseTimer > 0) {
                    const screenX = item.x - camera.x;
                    const screenY = item.y - camera.y;
                    const alpha = (item.pulseTimer / 2.0) * 0.8;
                    ctx.fillStyle = `rgba(220, 230, 255, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(screenX + item.w/2, screenY + item.h/2, TILE_SIZE, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            ctx.restore();
        }
    },

    LoreItems:{
        items: [],
        loreTexts: [ "It promises it will stop. It never does.", "Sometimes, the silence is worse than the screaming.", "I tried to be perfect, so it wouldn't be angry. It was never enough.", "It says this is for my own good. A lesson I need to learn.", "I'm so tired of walking on eggshells.", "The worst part is when it pretends to be nice again.", "You just get used to the constant dread. It becomes normal." ],
        generate() { this.items=[]; const numItems = 4; for(let i=0;i<numItems;i++){ let p=false; let attempts=0; while(!p && attempts<100){ attempts++; const x=Math.floor(Math.random()*MAP_WIDTH),y=Math.floor(Math.random()*MAP_HEIGHT); if(Game.Map.isWalkable(x,y)&&Math.hypot(x-Game.Map.playerStart.x,y-Game.Map.playerStart.y)>8){const text=this.loreTexts[Math.floor(Math.random()*this.loreTexts.length)]; this.items.push({x:x*TILE_SIZE+TILE_SIZE/2-8,y:y*TILE_SIZE+TILE_SIZE/2-8,w:16,h:16,text:text,pulseOffset:Math.random()*Math.PI,draw:function(ctx,frame){const p=0.6+Math.sin(frame*0.08+this.pulseOffset)*0.4;ctx.fillStyle=`rgba(220,220,200,${p*0.4+0.6})`;ctx.shadowColor='#fff';ctx.shadowBlur=10;ctx.fillRect(this.x,this.y,this.w,this.h);ctx.fillStyle='#333';ctx.font="bold 14px monospace";ctx.textAlign='center';ctx.fillText('?',this.x+this.w/2,this.y+this.h-2);ctx.textAlign='left';ctx.shadowBlur=0;}}); p=true;}}}},
        update(player) {
            this.items = this.items.filter(item => {
                if(Math.hypot(player.x - item.x, player.y - item.y) < TILE_SIZE/1.5){
                    Sound.play('lore_pickup'); Game.UI.showLoreMessage(item.text, 6);
                    return false;
                }
                return true;
            });
        }
    },
    
    RandomEvents: {
        items: [], activeEvent: null, eventTimer: 0,
        eventTypes: [
            { type: 'flashlight_flicker', duration: 3.5, chance: 0.3 },
            { type: 'whisper', duration: 0.1, chance: 0.2 },
            { type: 'wood_creak', duration: 0.1, chance: 0.15 }
        ],
        spawnTimer: 15,
        init() { this.items = []; this.activeEvent = null; this.spawnTimer = 10 + Math.random() * 10; },
        spawnEvent() {
            if (this.activeEvent) return;
            const eventType = this.eventTypes[Math.floor(Math.random() * this.eventTypes.length)];
            if(Math.random() > (eventType.chance || 1.0)) { this.spawnTimer = 5; return; }
            this.activeEvent = { ...eventType }; this.eventTimer = eventType.duration;
            if(eventType.type === 'whisper') Sound.play('event_whisper');
        },
        update(dt) {
            this.spawnTimer -= dt;
            if (this.spawnTimer <= 0) { this.spawnEvent(); this.spawnTimer = 15 + Math.random() * 15; }
            if (this.activeEvent) { this.eventTimer -= dt; if (this.eventTimer <= 0) this.activeEvent = null; }
        },
        getFlashlightModifier() {
            if (this.activeEvent && this.activeEvent.type === 'flashlight_flicker') { return Math.random() > 0.2 ? (Math.random() * 0.4) : 1; }
            return 1;
        }
    },
    
    GlitchSystem: {
        hudGlitch: false, hudGlitchTimer: 0, hudTimeToNext: 0,
        screenShift: false, shiftTimer: 0, shiftTimeToNext: 0, shiftX: 0, shiftY: 0,
        init() {
            this.hudGlitch = false; this.hudGlitchTimer = 0; this.hudTimeToNext = 15 + Math.random() * 20;
            this.screenShift = false; this.shiftTimer = 0; this.shiftTimeToNext = 25 + Math.random() * 30;
        },
        update(dt) {
            this.hudTimeToNext -= dt; this.shiftTimeToNext -= dt;
            if (this.hudTimeToNext <= 0) { this.hudGlitch = true; this.hudGlitchTimer = 0.3 + Math.random() * 0.4; this.hudTimeToNext = 20 + Math.random() * 25; }
            if (this.shiftTimeToNext <= 0) { this.screenShift = true; this.shiftTimer = 0.1; this.shiftTimeToNext = 30 + Math.random() * 30; this.shiftX = (Math.random()-0.5) * 50; this.shiftY = (Math.random()-0.5) * 20; Sound.play('static_burst'); }
            
            if (this.hudGlitch) { this.hudGlitchTimer -= dt; if (this.hudGlitchTimer <= 0) this.hudGlitch = false; }
            if (this.screenShift) { this.shiftTimer -= dt; if (this.shiftTimer <= 0) this.screenShift = false; }
        },
        applyScreenGlitch(ctx) {
            if (this.screenShift) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                const x = this.shiftX * (this.shiftTimer / 0.1);
                const y = this.shiftY * (this.shiftTimer / 0.1);
                ctx.drawImage(ctx.canvas, x, y);
                ctx.fillStyle = `rgba(255,0,0,0.1)`; ctx.fillRect(0,0,ctx.canvas.width, ctx.canvas.height);
                ctx.drawImage(ctx.canvas, -x, -y);
                ctx.fillStyle = `rgba(0,0,255,0.1)`; ctx.fillRect(0,0,ctx.canvas.width, ctx.canvas.height);
                ctx.restore();
            }
        },
        applyChaseEffects(ctx) {
            const width = ctx.canvas.width;
            const height = ctx.canvas.height;
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            const xOffset = (Math.random() - 0.5) * 12;
            const yOffset = (Math.random() - 0.5) * 12;
            ctx.globalAlpha = 0.8;
            ctx.drawImage(ctx.canvas, xOffset, yOffset);
            ctx.fillStyle = `rgba(255,0,0,0.15)`; ctx.fillRect(0,0,width,height);
            ctx.drawImage(ctx.canvas, -xOffset, -yOffset);
            ctx.fillStyle = `rgba(0,0,255,0.15)`; ctx.fillRect(0,0,width,height);
            ctx.restore();
            if (Math.random() > 0.8) {
                ctx.save();
                const y = Math.random() * height;
                const h = Math.random() * 20 + 5;
                const xShift = (Math.random() - 0.5) * 50;
                ctx.drawImage(ctx.canvas, 0, y, width, h, xShift, y, width, h);
                ctx.restore();
            }
            if (Math.random() > 0.95) {
                ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.2})`;
                ctx.fillRect(0, 0, width, height);
            }
            ctx.save();
            ctx.globalAlpha = 0.08;
            for (let i = 0; i < height / 4; i++) {
                ctx.fillStyle = `rgba(255,255,255,${Math.random() * 0.5})`;
                ctx.fillRect(Math.random() * width, Math.random() * height, Math.random() * 2, Math.random() * 2);
            }
            ctx.restore();
        }
    },

    FragmentLocator: {
        cooldown: 0, maxCooldown: 10, activeRadius: 0,
        init() { this.cooldown = 0; this.activeRadius = 0; },
        activate(player) {
            if (this.cooldown <= 0) {
                this.cooldown = this.maxCooldown;
                this.activeRadius = 1;
                Sound.play('locator_pulse');
            }
        },
        update(dt, collectibles) {
            if (this.cooldown > 0) this.cooldown -= dt;
            if (this.activeRadius > 0) {
                this.activeRadius += 1000 * dt;
                collectibles.forEach(c => {
                    const dist = Math.hypot(Game.Player.x - c.x, Game.Player.y - c.y);
                    if (dist < this.activeRadius && dist > this.activeRadius - 50) {
                        c.pulseTimer = 2.0;
                    }
                });
                if (this.activeRadius > 2000) this.activeRadius = 0;
            }
        },
        draw(ctx) {
            if (this.activeRadius > 0) {
                ctx.strokeStyle = `rgba(180, 200, 255, ${1 - (this.activeRadius / 2000)})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(Game.Player.x + Game.Player.w/2, Game.Player.y + Game.Player.h/2, this.activeRadius, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
    },

    Particles: {
        items: [],
        create(x, y, count, type, life, speed, angle) { for (let i = 0; i < count; i++) { const moveAngle = angle !== undefined ? angle : Math.random() * Math.PI * 2; const currentSpeed = Math.random() * speed; this.items.push({ x, y, vx: Math.cos(moveAngle) * currentSpeed, vy: Math.sin(moveAngle) * currentSpeed, life: life + Math.random() * life * 0.5, maxLife: life * 1.5, color: type, type: type, angle: moveAngle, sway: Math.random() * Math.PI * 2 }); }},
        update(dt) {
            this.items.forEach(p => { 
                if (p.type === 'leaf') { 
                    p.vy += 15 * dt; p.vx *= 0.98; 
                    p.x += Math.sin(p.sway + p.life * 4) * 15 * dt;
                }
                p.x += p.vx * dt; p.y += p.vy * dt; p.life -= dt;
            });
            this.items = this.items.filter(p => p.life > 0);
        },
        draw(ctx, screenSpace = false, footprintsOnly = false) {
            ctx.save();
            if(screenSpace) ctx.setTransform(1, 0, 0, 1, 0, 0); // Identity matrix
            
            this.items.forEach(p => {
                if (footprintsOnly && p.type !== 'blood_footprint') return;
                if (!footprintsOnly && p.type === 'blood_footprint') return;

                const alpha = p.life / p.maxLife;
                if (p.type === 'leaf') {
                    const grad = ctx.createLinearGradient(p.x-1, p.y-1, p.x+1, p.y+1);
                    grad.addColorStop(0, `rgba(40, 100, 40, ${alpha*0.5})`);
                    grad.addColorStop(1, `rgba(80, 150, 80, ${alpha*0.5})`);
                    ctx.fillStyle = grad;
                    ctx.fillRect(p.x-1.5, p.y-1.5, 3, 3);
                } else if (p.type === 'blood_footprint') {
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.angle);
                    ctx.fillStyle = `rgba(100, 10, 20, ${alpha * 0.6})`;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 3, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
                else {
                    ctx.fillStyle = `rgba(${p.color}, ${alpha * 0.8})`;
                    ctx.fillRect(p.x, p.y, 2, 2);
                }
            });
            ctx.restore();
        }
    },

    CreepyMessages: {
        items: [], messages: ["worthless", "it's your fault", "no one believes you", "pathetic", "you deserved it", "stop crying"], spawnTimer: 5,
        update(dt, camera) {
            this.spawnTimer -= dt;
            if (this.spawnTimer <= 0) {
                this.spawnTimer = 8 + Math.random() * 12;
                if (this.items.length < 3) { const text = this.messages[Math.floor(Math.random() * this.messages.length)]; const x = camera.x + Math.random() * camera.w; const y = camera.y + Math.random() * camera.h; this.items.push({ text, x, y, life: 2 + Math.random() * 2, maxLife: 4 }); }
            }
            this.items.forEach(m => m.life -= dt); this.items = this.items.filter(m => m.life > 0);
        },
        draw(ctx) {
            this.items.forEach(m => {
                const flicker = Math.random() > 0.1 ? 1 : 0; const lifePercent = m.life / m.maxLife; const alpha = lifePercent < 0.25 ? lifePercent * 4 : (lifePercent > 0.75 ? (1 - lifePercent) * 4 : 1);
                ctx.font = "bold 28px 'Courier New', monospace"; ctx.textAlign = 'center';
                const gx = (Math.random() - 0.5) * 6; const gy = (Math.random() - 0.5) * 6;
                ctx.fillStyle = `rgba(180, 0, 0, ${alpha * 0.7 * flicker})`; ctx.fillText(m.text, m.x + gx, m.y + gy);
                ctx.fillStyle = `rgba(200, 200, 200, ${alpha * flicker})`; ctx.fillText(m.text, m.x, m.y); ctx.textAlign = 'left';
            });
        }
    },

    Camera:{x:0,y:0,w:0,h:0,shakeDuration:0,shakeMagnitude:0,init(p){this.w=Game.canvas.width;this.h=Game.canvas.height;this.update(p);},update(p){this.x=p.x-this.w/2;this.y=p.y-this.h/2;this.x=Math.max(0,Math.min(this.x,MAP_WIDTH*TILE_SIZE-this.w));this.y=Math.max(0,Math.min(this.y,MAP_HEIGHT*TILE_SIZE-this.h));},applyTransform(ctx){let sX=0,sY=0;if(this.shakeDuration>0){this.shakeDuration-=Game.deltaTime;sX=(Math.random()-0.5)*this.shakeMagnitude;sY=(Math.random()-0.5)*this.shakeMagnitude;}ctx.translate(-Math.floor(this.x)+sX,-Math.floor(this.y)+sY);},shake(d,m){this.shakeDuration=d;this.shakeMagnitude=m;}},
    
    UI:{
        glitchChars: "!@#$%^&*()_+[]{};':\"|\\<>,./?",
        glitchText(text) { return text.split('').map(char => (Math.random() > 0.3) ? char : this.glitchChars[Math.floor(Math.random() * this.glitchChars.length)]).join(''); },
        drawGlitchedStaminaBar(ctx, barX, barY, barW, barH, fill) { for (let i = 0; i < 10; i++) { if (Math.random() > 0.2) { const jitterY = (Math.random() - 0.5) * 4; ctx.fillRect(barX + (Math.random() * fill), barY + jitterY, (Math.random() * 20), barH); }}},
        activeLoreMessage: { text: '', timer: 0, maxTime: 0 },
        draw(ctx,game){
            if(game.state === GAME_STATE.GAME_OVER){
                this.drawGameOverScreen(ctx);
                return;
            }
            if (game.state === GAME_STATE.WIN) { this.drawWinScreen(ctx, game); return; }
            if (game.state === GAME_STATE.TITLE) { this.drawTitleUI(ctx); return; }
            if (game.state === GAME_STATE.PAUSED) { this.drawOverlay(ctx,'PAUSED','Press P to resume'); return; }

            ctx.font="24px 'Courier New',monospace";
            let fragmentsText = `SOUL FRAGMENTS: ${game.Collectibles.score}/${game.Collectibles.totalItems}`;
            ctx.fillStyle = Game.GlitchSystem.hudGlitch ? '#f55' : '#ccc';
            ctx.fillText(Game.GlitchSystem.hudGlitch ? this.glitchText(fragmentsText) : fragmentsText, 20, 40);
            
            if(game.Collectibles.unlocked){ctx.fillStyle='#aaffaa';ctx.shadowColor='#afa';ctx.shadowBlur=10;ctx.fillText('THE CABIN... IT CALLS TO YOU',20,70);ctx.shadowBlur=0;}
            
            const p=game.Player,staminaBarY=game.canvas.height-30,staminaBarX=20,staminaBarW=200,staminaBarH=15;
            ctx.strokeStyle='#888';ctx.fillStyle='rgba(0,0,0,0.5)';ctx.fillRect(staminaBarX-2,staminaBarY-2,staminaBarW+4,staminaBarH+4);ctx.strokeRect(staminaBarX-2,staminaBarY-2,staminaBarW+4,staminaBarH+4);
            ctx.fillStyle=p.stamina>25?'#ffffaa':'#ffaa88';
            const staminaFill = staminaBarW*(p.stamina/p.maxStamina);
            if (Game.GlitchSystem.hudGlitch) { this.drawGlitchedStaminaBar(ctx, staminaBarX, staminaBarY, staminaBarW, staminaBarH, staminaFill); }
            else { ctx.fillRect(staminaBarX,staminaBarY, staminaFill, staminaBarH); }
            
            const locator = game.FragmentLocator;
            const cooldownFill = locator.cooldown > 0 ? (1 - (locator.cooldown / locator.maxCooldown)) : 1;
            ctx.fillStyle = '#668'; ctx.fillRect(game.canvas.width - 60, game.canvas.height - 40, 40, 20);
            ctx.fillStyle = '#aaddff'; ctx.fillRect(game.canvas.width - 60, game.canvas.height - 40, 40 * cooldownFill, 20);
            ctx.fillStyle = '#fff'; ctx.font="bold 18px monospace"; ctx.textAlign='center'; ctx.fillText('F', game.canvas.width - 40, game.canvas.height - 23); ctx.textAlign='left';

            this.drawLoreMessage(ctx);
        },
        drawTitleUI(ctx) {
            ctx.textAlign = 'center';
            const title = "Red Light Nightmare";
            const subtitle = "Press any key to begin...";

            // Chromatic aberration title
            const offset = 4;
            ctx.font = "bold 96px 'Courier New', monospace";
            ctx.fillStyle = 'rgba(255, 0, 0, 0.7)'; ctx.fillText(title, ctx.canvas.width/2 + offset, ctx.canvas.height/2 - 80);
            ctx.fillStyle = 'rgba(0, 255, 255, 0.7)'; ctx.fillText(title, ctx.canvas.width/2 - offset, ctx.canvas.height/2 - 80);
            ctx.fillStyle = '#fff'; ctx.fillText(title, ctx.canvas.width/2, ctx.canvas.height/2 - 80);

            // Subtitle
            ctx.fillStyle = '#ccc';
            ctx.font = "24px 'Courier New', monospace";
            ctx.fillText(subtitle, ctx.canvas.width/2, ctx.canvas.height/2 - 20);

            // Credits
            ctx.font = "22px 'Courier New', monospace";
            ctx.fillStyle = '#888';
            ctx.fillText("A nightmare by", ctx.canvas.width/2, ctx.canvas.height/2 + 60);

            ctx.font = "bold 36px 'Courier New', monospace";
            ctx.shadowColor = '#f00';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#f00';
            ctx.fillText("@gbleandroo", ctx.canvas.width/2, ctx.canvas.height/2 + 100);
            ctx.shadowBlur = 0;

            ctx.textAlign = 'left';
        },
        showLoreMessage(text, duration) { this.activeLoreMessage = { text, timer: duration, maxTime: duration }; },
        drawLoreMessage(ctx) {
            if (this.activeLoreMessage.timer > 0) {
                const lifePercent = this.activeLoreMessage.timer / this.activeLoreMessage.maxTime;
                const alpha = lifePercent < 0.2 ? lifePercent*5 : (lifePercent > 0.8 ? (1-lifePercent)*5 : 1);
                ctx.textAlign = 'center'; ctx.font = "italic 22px 'Courier New', monospace";
                ctx.fillStyle = `rgba(200, 200, 200, ${alpha * 0.8})`;
                ctx.shadowColor = `rgba(0,0,0,${alpha})`; ctx.shadowBlur = 5;
                ctx.fillText(this.activeLoreMessage.text, Game.canvas.width/2, Game.canvas.height - 50);
                ctx.textAlign = 'left'; ctx.shadowBlur = 0;
            }
        },
        drawWinScreen(ctx, game){
            const duration = 300;
            const progress = Math.min(1, game.winFrame / duration);
            ctx.fillStyle = `rgba(0, 0, 0, ${progress})`; ctx.fillRect(0, 0, game.canvas.width, game.canvas.height);
            if (progress >= 0.5) {
                const textAlpha = (progress - 0.5) * 2;
                ctx.textAlign = 'center'; ctx.font = "bold 48px 'Courier New', monospace";
                const text = "You made it... or did you?";
                const glitchX = (Math.random() - 0.5) * 8; const glitchY = (Math.random() - 0.5) * 8;
                ctx.fillStyle = `rgba(255, 0, 0, ${0.5 * textAlpha * Math.random()})`; ctx.fillText(text, game.canvas.width/2 + glitchX, game.canvas.height/2 + glitchY);
                ctx.fillStyle = `rgba(0, 255, 255, ${0.5 * textAlpha * Math.random()})`; ctx.fillText(text, game.canvas.width/2 - glitchX, game.canvas.height/2 - glitchY);
                ctx.fillStyle = `rgba(255, 255, 255, ${textAlpha})`; ctx.fillText(text, game.canvas.width/2, game.canvas.height/2);
                if (progress >= 0.8) {
                    ctx.font = "24px 'Courier New', monospace";
                    ctx.fillStyle = `rgba(200, 200, 200, ${(progress - 0.8) * 5})`;
                    ctx.fillText("Press R to face the nightmare again.", game.canvas.width/2, game.canvas.height/2 + 60);
                }
            }
        },
        drawOverlay(ctx,title,subtitle,color='#fff',drawBg=true){if(drawBg){ctx.fillStyle='rgba(0,0,0,0.7)';ctx.fillRect(0,0,Game.canvas.width,Game.canvas.height);}ctx.fillStyle=color;ctx.font="bold 72px 'Courier New',monospace";ctx.textAlign='center';ctx.fillText(title,Game.canvas.width/2,Game.canvas.height/2-40);ctx.fillStyle='#ccc';ctx.font="24px 'Courier New',monospace";ctx.fillText(subtitle,Game.canvas.width/2,Game.canvas.height/2+20);ctx.textAlign='left';},
        drawGameOverScreen(ctx) {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            
            ctx.save();
            const shakeX = (Math.random() - 0.5) * 15;
            const shakeY = (Math.random() - 0.5) * 15;
            ctx.translate(shakeX, shakeY);
            
            const text = 'I AM WATCHING YOU';
            ctx.textAlign = 'center';
            ctx.font = "bold 72px 'Courier New', monospace";
            
            ctx.globalCompositeOperation = 'lighter';
            ctx.fillStyle = `rgba(255, 0, 0, 0.7)`; ctx.fillText(text, ctx.canvas.width/2 + (Math.random()-0.5)*8, ctx.canvas.height/2 + (Math.random()-0.5)*8);
            ctx.fillStyle = `rgba(0, 255, 255, 0.7)`; ctx.fillText(text, ctx.canvas.width/2 + (Math.random()-0.5)*8, ctx.canvas.height/2 + (Math.random()-0.5)*8);
            ctx.globalCompositeOperation = 'source-over';
            
            ctx.fillStyle = '#fff';
            ctx.fillText(text, ctx.canvas.width/2, ctx.canvas.height/2);
            
            ctx.fillStyle = '#ccc';
            ctx.font = "24px 'Courier New', monospace";
            ctx.fillText('Press R to return to the nightmare', ctx.canvas.width/2, ctx.canvas.height/2 + 60);
            
            ctx.restore();
        },
        drawCursor(ctx,mouse){ctx.fillStyle='rgba(255,255,255,0.5)';ctx.beginPath();ctx.arc(mouse.x,mouse.y,5,0,Math.PI*2);ctx.fill();}
    }
};

Game.init();
})();
</script>
</body>
</html>